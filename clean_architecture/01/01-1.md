## 더 쉬운 예시로 이해하기

### 1. 식당 주방을 생각해봅시다:

- Before (의존성 역전 전):
```typescript
class Chef {
  private gasCooker = new GasCooker();  // 셰프가 가스레인지에 직접 의존
  
  cookSteak() {
    this.gasCooker.turnOn();
    this.gasCooker.setTemperature(200);
    // 요리 과정...
  }
}
```
- 문제점: 인덕션으로 바꾸고 싶으면? 셰프의 코드를 다 고쳐야 함!


- After (의존성 역전 후):
```typescript
interface Cooker {  // "요리 도구"라는 추상적인 개념
  turnOn(): void;
  setTemperature(degree: number): void;
}

class Chef {
  constructor(private cooker: Cooker) {}  // 셰프는 "요리 도구"라는 개념만 알면 됨
  
  cookSteak() {
    this.cooker.turnOn();
    this.cooker.setTemperature(200);
    // 요리 과정...
  }
}

// 실제 도구들은 이 개념(인터페이스)을 따르도록 만듦
class GasCooker implements Cooker { ... }
class InductionCooker implements Cooker { ... }
```

### 2. 실제 사용 예시:
```typescript
// Before: 셰프가 가스레인지에 종속됨
const chef = new Chef();  // 무조건 가스레인지만 씀

// After: 어떤 도구를 쓸지는 나중에 결정
const gasCooker = new GasCooker();
const inductionCooker = new InductionCooker();

const chef1 = new Chef(gasCooker);       // 가스레인지로 요리하는 셰프
const chef2 = new Chef(inductionCooker);  // 인덕션으로 요리하는 셰프
```

### 3. "역전"이라고 부르는 이유:
1. 전통적인 의존성:
   - 고수준(셰프) → 저수준(가스레인지)
   - "셰프는 가스레인지가 어떻게 작동하는지 다 알아야 함"

2. 역전된 의존성:
   - 저수준(가스레인지, 인덕션) → 추상화(요리도구 인터페이스) ← 고수준(셰프)
   - "가스레인지와 인덕션이 요리도구의 규칙을 따라야 함"
   - "셰프는 요리도구의 사용법만 알면 됨"

이렇게 하면:
1. 새로운 도구가 나와도 셰프는 재교육이 필요 없음
2. 도구만 바꿔끼우면 됨
3. 가짜 도구로 셰프의 실력을 테스트하기도 쉬움